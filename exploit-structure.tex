\label{chap:exploit-structure}

With the mesh data laid out conveniently in memory, alongside the meta-data express the detected structure, we discuss how the core-computation may be modified to use the structure which we have extracted.

\section{Basic structured region parameters}
Recall our skeleton example in figure~\ref{subfig:crystal-loop} of a core-computation loop over structured and unstructured regions. Figure~\ref{fig:skeleton-structured-loop} shows the skeleton of a similar loop structure, except that the iteration is over the structured regions of a cell-vertex relation-map. While this loop faithfully shows the general loop structure, it glosses over much of the important detail.

\begin{figure}
\newsavebox{\thelisting}
\begin{lrbox}{\thelisting}
\begin{lstlisting}[language=python]
for region in structured_regions:
	for row in region.interior_structured_rows:
		for column in region.interior_structured_cols:
			# Compute cell_id and vertex_ids ... (details omitted)
			kernel_function(cell_id, vertex_ids)

# Loop over unstructured region (omitted)
\end{lstlisting}
\end{lrbox}

\usebox{\thelisting}
\caption{Pseudo-code of a loop over structured regions with respect to a cell-vertex relation-map.}
\label{fig:skeleton-structured-loop}
\end{figure}

\section{Structured region boundaries}
We first consider the meta-data we need to store for each structured region; the loop skeleton provides some hints at this, as it uses the \lstinline|interior_structured_rows| and \lstinline|interior_structured_cols| fields associated with each structured region.



Let us consider the example mesh from figure~\ref{fig:renumbering}, which is modified in figure~\ref{fig:structured-cell-mesh} to highlight the cell-vertex relation-map. We would like the structured region loop to iterate over the interior structured elements (the lightly coloured cells in the example). Since a all structured regions are fundamentally based on a vertex structured region, we parametrize the interior structured region on that basis. The following parameters allow us to specify the iteration space directly:
\begin{itemize}
\item The first structured \emph{vertex} in the structured region (\emph{first vertex}).
\item The number of \emph{vertex} rows\footnote{Strictly speaking we may omit the number of vertex rows} and columns in the structured region (\emph{\#rows} and \emph{\#cols}).
\item The \emph{vertex} offset in rows and columns from which the sub-rectangle of interior structured elements begin (\emph{interior start row offset} and \emph{interior start col offset}).
\item The \emph{vertex} offset in rows and columns to which the sub-rectangle of interior structured elements extends (\emph{interior end row offset} and \emph{interior end col offset}).
\item The first structured element in the structured region (\emph{first element}).
\end{itemize}

Based on these parameters we can write a loop over structured regions, as show in figure~\ref{fig:detailed-structured-loop}


% Mesh image
\begin{figure}
\sidebysidethreevertical
{
	\includesvg[width=\imagewidth, svgpath=images/exploit/]{vertex-metadata}
	\caption{A mesh with two structured regions, coloured in blue and red. Vertices are indicated by circles. Lighter shades denote interior structured elements, and darker shades denote fringe structured elements.}
}
{
	\small
	\tabcolsep=0.32mm
	\include{supp/vertex-dat}
	\caption{The vertex storage layout in memory. The numbers indicate vertex ids, and the colours correspond to the mesh diagram above.}
}
{
	\small
	\tabcolsep=0.32mm
	\include{supp/dat3}
	\caption{The cell storage layout in memory. The numbers indicate cell ids, and the colours correspond to the mesh diagram above.}
}
\caption{A reproduced version of figure~\ref{fig:renumbering}, annotated with structured region meta-data; the mesh depicts cell structured regions and their boundaries as induced by a cell-vertex relation-map.}
\label{fig:structured-cell-mesh}
\end{figure}


%% Loop without reordering
\begin{figure}
\newsavebox{\structureloopb}
\begin{lrbox}{\structureloopb}
\begin{lstlisting}[language=python]
for region in structured_regions:
	num_cell_cols = 1 + region.interior_end_col_offset - region.interior_end_start_offset
	num_vtx_cols = region.num_cols
	vtx_base = region.first_vertex

	for row in [region.interior_start_row_offset .. region.interior_end_row_offset]:
		for col in [region.interior_start_col_offset .. region.interior_end_col_offset]:
			cell_id = region.first_element + num_cell_cols*row + col

			vertex0_id = vtx_base + num_vtx_cols*row + col
			vertex1_id = vtx_base + num_vtx_cols*row + (col + 1)
			vertex2_id = vtx_base + num_vtx_cols*(row + 1) + col
			vertex3_id = vtx_base + num_vtx_cols*(row + 1) + (col + 1)

			vertex_ids = [vertex0_id, vertex1_id, vertex2_id, vertex3_id]


			kernel_function(cell_id, vertex_ids)

# Loop over unstructured region (omitted)
\end{lstlisting}
\end{lrbox}

\usebox{\structureloopb}
\caption{The loop from figure~\ref{fig:skeleton-structured-loop} expanded to show more detail, particularly of address calculation.}
\label{fig:detailed-structured-loop}
\end{figure}



\section{Applying neighbour reordering}
\label{sec:apply-reordering}
In section~\ref{sec:neighbour-ordering-intro} we discussed the problem of neighbour ordering, and proposed solutions to tackle the problem. Our chosen approach was to fix a single ordering for each structured region, and store it as meta-data. To apply this in our structured loop, we define a simple function (shown in figure~\ref{fig:reordering-funcs}) which takes an ordered sequence of elements, and a ``compass'' defining the ordering of the neighbours, and returns the reordered sequence of elements. The reordering function can then be used straightforwardly as shown in figure~\ref{fig:final-structured-loop}


% REORDER FUNC
\begin{figure}
\newsavebox{\reorderelements}
\begin{lrbox}{\reorderelements}
\begin{lstlisting}[language=python]
# elements is an array of four elements
# compass is a permutation of [0, 1, 2, 3]
def reorder_four_elements(elements, compass):
	e0 = elements[compass[0]]
	e1 = elements[compass[1]]
	e2 = elements[compass[2]]
	e3 = elements[compass[3]]

	return [e0, e1, e2, e3]
\end{lstlisting}
\end{lrbox}

\newsavebox{\reorderelementsb}
\begin{lrbox}{\reorderelementsb}
\begin{lstlisting}[language=python]
# elements is an array of n elements
# compass is a permutation of 0..n-1
def reorder_elements(elements, compass):
	new_elements = []

	for target_index in compass:
		elements.append(elements[target_index])

	return new_elements
\end{lstlisting}
\end{lrbox}

\sidebysideverticalnoncenter
{
\usebox{\reorderelements}
\caption{A function to apply a reordering of four elements.}
\label{subfig:reoder-four}
}
{
\usebox{\reorderelementsb}
\caption{A generalised function to apply a reordering to an arbitrary number of elements.}
\label{subfig:reorder-n}
}
\caption{Definition of functions that apply a reordering to mesh elements.}
\label{fig:reordering-funcs}
\end{figure}


% LOOP WITH REORDERING
\begin{figure}
\newsavebox{\structureloopc}
\begin{lrbox}{\structureloopc}
\begin{lstlisting}[language=python]
for region in structured_regions:
	num_cell_cols = 1 + region.interior_end_col_offset - region.interior_end_start_offset
	num_vtx_cols = region.num_cols
	vtx_base = region.first_vertex

	for row in [region.interior_start_row_offset .. region.interior_end_row_offset]:
		for col in [region.interior_start_col_offset .. region.interior_end_col_offset]:
			cell_id = region.first_element + num_cell_cols*row + col

			vertex0_id = vtx_base + num_vtx_cols*row + col
			vertex1_id = vtx_base + num_vtx_cols*row + (col + 1)
			vertex2_id = vtx_base + num_vtx_cols*(row + 1) + col
			vertex3_id = vtx_base + num_vtx_cols*(row + 1) + (col + 1)

			vertex_ids = [vertex0_id, vertex1_id, vertex2_id, vertex3_id]
			reordered_vertex_ids = reorder_four_elements(vertex_ids, region.compass)

			kernel_function(cell_id, reordered_vertex_ids)

# Loop over unstructured region (omitted)
\end{lstlisting}
\end{lrbox}

\usebox{\structureloopc}
\caption{The loop from figure~\ref{fig:detailed-structured-loop} with reordering including.}
\label{fig:final-structured-loop}
\end{figure}

\section{Chapter summary}
In this chapter we covered how the core-computation loop can be transformed to \emph{exploit} the detected structured regions by making use of the meta-data associated with them.